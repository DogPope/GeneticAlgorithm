# -*- coding: utf-8 -*-
"""T00158237GeneticAlgorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FrcoU2txxIX7zOJHRJ6XPoC72tPY_kds

# Genetic Algorithm Assignment
30% of the overall grade for this module  
Marks indciated in sections below are based on percentage of marks allocated for this module  
In this assignment you must choose a problem, and attempt to use the Genetic Alogrithm that we developed in class to solve this problem.

---

# Genetic Algorithm on Snake

This program will attempt to check if the Genetic Algorithm can successfully be implemented to run on the popular game, Snake. This will involve tying the necessary variables between programs, and see if the output from the program can be improved based on that.

- Chromosome: The chromosome in this case is going to be how long the program has run, or a series of directions taken by the program.
- Fitness Function: This will check the overall goal, otherwise the score of the program.
- Crossover: This describes where the program will deviate from other chromosomal iterations, combining the outputs of the two to make one, better output.

---
"""

import random
import numpy as np
class Snake:
    def __init__(self, chromosome=None):
      self.board = [
        ['#', '-', '-', '-', '-', '-', '-', '#'],
        ['|', ' ', ' ', ' ', ' ', ' ', ' ', '|'],
        ['|', ' ', ' ', ' ', ' ', ' ', ' ', '|'],
        ['|', ' ', ' ', ' ', ' ', ' ', ' ', '|'],
        ['|', ' ', ' ', ' ', ' ', ' ', ' ', '|'],
        ['#', '-', '-', '-', '-', '-', '-', '#']
      ]
      self.snake = [(3, 3)] # Hard coded starting position
      self.direction = 'w' # Always starts facing up
      self.moves = []
      self.height = len(self.board)
      self.width = len(self.board[0])
      self.score = 0
      self.chromosome = chromosome
      self.place_snake()
      self.generate_food()

    def place_snake(self):
      head_x, head_y = self.snake[0]
      self.board[head_x][head_y] = '0'

    def generate_food(self):
      for i in range(self.height):
        for j in range(self.width):
          if self.board[i][j] == '@':
            self.board[i][j] = ' '
      valid_positions = []
      for i in range(1, self.height - 1):
        for j in range(1, self.width - 1):
          if (i, j) not in self.snake and self.board[i][j] == ' ':
            valid_positions.append((i, j))

      if valid_positions:
        food_x, food_y = random.choice(valid_positions)
        self.board[food_x][food_y] = '@'
        return (food_x, food_y)
      else:
        return None

    def display_board(self):
      for row in self.board:
        print(' '.join(str(cell) for cell in row))

    def accept_input(self, chromosome, move_index):
      if move_index < len(chromosome):
        move_value = chromosome[move_index]
        if 0 <= move_value < 1:
            move = 'w'
        elif 1 <= move_value < 2:
            move = 's'
        elif 2 <= move_value < 3:
            move = 'a'
        elif 3 <= move_value <= 4:
            move = 'd'
        else:
            move = self.direction
        self.moves.append(move)
        return move # If invalid move, keep moving in same direction.

    def move_snake(self):
      head_x, head_y = self.snake[0]
      if self.direction == "w":
        new_head = (head_x - 1, head_y) # Up
      elif self.direction == "s":
        new_head = (head_x + 1, head_y) # Down
      elif self.direction == "a":
        new_head = (head_x, head_y - 1) # Left
      elif self.direction == "d":
        new_head = (head_x, head_y + 1) # Right

      new_x, new_y = new_head # Validate head
      if (self.board[new_x][new_y] == '#' or
        self.board[new_x][new_y] == '-' or
        self.board[new_x][new_y] == '|' or
        new_head in self.snake):
        return False

      food_eaten = self.board[new_x][new_y] == '@'

      self.snake.insert(0, new_head)
      self.board[new_x][new_y] = '0'

      if len(self.snake) > 1:
        prev_head_x, prev_head_y = self.snake[1]
        self.board[prev_head_x][prev_head_y] = 'o'

      if not food_eaten:
        tail_x, tail_y = self.snake.pop()
        self.board[tail_x][tail_y] = ' '
      else:
        self.score += 1
        self.generate_food()
      return True

    def play_game(self, chromosome):
      game_over = False
      move_index = 0
      while not game_over:
        self.direction = self.accept_input(chromosome, move_index)
        game_over = not self.move_snake()
        move_index += 1

      print(f"The result is: {self.moves}, Score: {self.score}")
      return self.score, self.moves

"""## The Problem         **(~30%)**

*   Description of the problem

*   Discussion of the suitablity of Genetic Algorithms

---

A Genetic Algorithm implementation would be suitable for this project because it allows for parameters of a program to be treated like a genetic problem, with various parameters that could be improved upon, such as moves taken, overall score and so on.

This algorithm could take outputs from the previous program and use them to define the best solution from a given set, allowing for re-insertion into the program to create an iteratively better solution than the previous one.

---

*   Complexity of the problem  (Overall marks allocated based on ..)
---

This is not an overly complex problem. All it is, really, is taking a simplistic output from the Snake program, the length and score on the board, and using that to find the optimal solution from within the given set.

# The problem and the cost function   **(~20%)**
The cost function here will attempt to return a cost value from the program. In this case, it will be the score divided by the number of moves it takes, which should negatively enforce taking too long to reach the food, and heavily reward it for getting food.
"""

class problem:
  def cost_function(self, chromosome): # Cost Function returns negative value for negative reinforcement
    game = Snake(chromosome = chromosome)
    score, moves = game.play_game(chromosome)
    if score == 0:
      cost = 1 / (len(moves) + 1)
    else:
      cost = score + (score / len(moves))
    cost = score / len(moves)
    return -cost
  def __init__(self):
    self.number_of_genes = 100
    self.min_value = 0
    self.max_value = 4 # only 4 directions
    self.acceptable_cost = -0.5 # Had to be changed to negative for negative reinforcement system.

"""# The Individual **(~30%)**
- Chromosome - The chromosome in this case is going to be the list of directions that the program has taken.

- Crossover - This will involve taking the program output and deciding on a suitable time to change to another chromosomal output. A good time to consider changing this is when the snake has eaten food, or how quickly it can get to its destination.

- Mutation - This describes a chromosome that has been through the previous step and is either selected or rejected based on how well it did.

## Discussion and justification on the approaches taken for the above
"""

from copy import deepcopy
class individual:
  def __init__(self,problem):
    self.chromosome = np.random.uniform(problem.min_value, problem.max_value, problem.number_of_genes)
    self.cost = problem.cost_function(self.chromosome)

  def mutate(self, rate_of_gene_mutation, range_of_gene_mutation):
    for index in range(len(self.chromosome)):
      if  np.random.uniform() < rate_of_gene_mutation:
        self.chromosome[index] += np.random.randn() * range_of_gene_mutation

  def crossover(self, parent2, explore_crossover):
    alpha = np.random.uniform(-explore_crossover, 1+explore_crossover)
    child1 = deepcopy(self)
    child2 = deepcopy(parent2)
    child1.chromosome = alpha * self.chromosome + (1-alpha) * parent2.chromosome
    child2.chromosome = alpha * parent2.chromosome + (1-alpha) * self.chromosome
    return child1,child2

"""---

I think this could be a suitable method for improving the program, because it takes a set of results from it and goes on to use it for improving it incrementally. The improvement stems from two factors.
- Score: This describes how well the program did overall, and is the most important factor in determining the success of the algorithm.
- Directions: This describes how long the program ran, and any number of changes here could indicate a variety of different things.
For example, if the computer moves in a circle, it would indefinitely increase the number of moves made, which is not necessarily a good or bad outcome.

The two given factors need to be tied to each other to assess performance. The computer should ideally aim to go on for as long as it takes for the Snake to be forced to eat itself at some point, meaning it's score keeps increasing.

A Genetic Algorithm implementation could take the better program outputs to make better decisions going forward, using the previous iterations for exactly this purpose.

---

## Running the algorithm  **(~10%)**

*   Parameter choices
*   Modifications (if any) to run_genetic
*   Rationale for the above

---

I have reduced the sample size for less iterations. This will make the program run faster at the expense of having more usable data. It also reduces the chances of unforeseen errors.

---
"""

class parameters:
  def __init__(self):
    self.population = 100 # Adjusted for a smaller sample size.
    self.max_number_of_generations = 25
    self.birth_rate_per_generation = 0.5
    self.explore_crossover_range = 0.2
    self.gene_mutation_range = 0.5
    self.gene_mutation_rate = 0.2

def choose_parents(population):
  index1 = np.random.randint(population)
  index2 = np.random.randint(population)
  if index1 == index2:
    return choose_parents(population)
  return index1, index2

def run_genetic(problem, parameters):
  number_in_population = parameters.population
  rate_of_gene_mutation = parameters.gene_mutation_rate
  range_of_gene_mutation = parameters.gene_mutation_range
  explore_crossover = parameters.explore_crossover_range
  max_number_of_generations = parameters.max_number_of_generations
  cost_function = problem.cost_function
  acceptable_cost = problem.acceptable_cost
  number_of_children_per_generation = number_in_population * parameters.birth_rate_per_generation

  population = []
  best_solution = individual(problem)
  best_solution.cost = np.inf

  for i in range(number_in_population):
    new_individual = individual(problem)
    if new_individual.cost < best_solution.cost:
      best_solution = deepcopy(new_individual)
    population.append(new_individual)
  print(f"Initial Population Size: {len(population)}")
  print(f"Initial Best Cost: {best_solution.cost}")

  for i in range(max_number_of_generations):
    print(f"Generation: {i + 1}")
    children = []
    while len(children) < number_of_children_per_generation:
      parent1_index, parent2_index = choose_parents(number_in_population)

      parent1 = population[parent1_index]
      parent2 = population[parent2_index]

      child1, child2 = parent1.crossover(parent2, explore_crossover)
      child1.mutate(rate_of_gene_mutation, range_of_gene_mutation)
      child2.mutate(rate_of_gene_mutation, range_of_gene_mutation)
      child1.cost = cost_function(child1.chromosome)
      child2.cost = cost_function(child2.chromosome)
      children.append(child1)
      children.append(child2)

    population += children
    population = sorted(population, key=lambda x: x.cost)
    population = population[:number_in_population]
    if population[0].cost < best_solution.cost:
      best_solution = deepcopy(population[0])
      print(f"New best cost: {best_solution.cost}")
      game = Snake(chromosome = best_solution.chromosome)
      game.play_game(best_solution.chromosome)
      game.display_board()
    if best_solution.cost < acceptable_cost:
      break
  return population, best_solution

problem = problem()
parameters = parameters()
population, solution = run_genetic(problem, parameters)
print(f"Best Solution: {solution.chromosome}")
print(f"Best Cost: {solution.cost}")

"""## Results and conclusions    **(~10%)**

---

The algorithm worked in a limited manner. It was not capable of completing the game, but it did roughly improve the output by taking the previous outputs and adding the ability to asssess them based on factors such as the score and the history of the moveset.

It was still not close to a human performance, although it did improve the final result slightly.

The final best cost is generally a negative number, representing lower costs, therefore a better solution. It ranges between negative one-third and negative two-thirds in most iterations.

---
"""